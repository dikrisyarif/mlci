import { DB_CONFIG } from './config';
import { logDbOperation } from './monitor';
import { 
  initDb, 
  getDb, 
  queueOperation, 
  executeWithLog,
  forceCleanupDatabase
} from './operations';
import { migrateDatabase, isSameDay } from './migration';

// Initialize database and create tables
export const initDatabase = async () => {
  logDbOperation('init', 'started');
  
  try {
    const db = await initDb();

    // Check current version
    const versionResult = await queueOperation(async () => {
      return await db.getFirstAsync(
        'SELECT value FROM metadata WHERE key = ?',
        ['db_version']
      );
    }, 'Get database version');

    const currentVersion = versionResult ? parseInt(versionResult.value, 10) : 0;

    // Migrate if needed
    if (currentVersion !== DB_CONFIG.version) {
      await migrateDatabase(db, currentVersion, DB_CONFIG.version);
      await queueOperation(async () => {
        await db.runAsync(
          'INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)',
          ['db_version', DB_CONFIG.version.toString()]
        );
      }, 'Update database version');
    }
    
    logDbOperation('init', 'completed');
    return db;
  } catch (error) {
    logDbOperation('init', 'failed', { error });
    throw error;
  }
};

// Reset database
export const resetDatabase = async () => {
  logDbOperation('reset', 'started');
  
  try {
    await forceCleanupDatabase();
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const db = await initDb();
    const today = new Date().toISOString().split('T')[0];

    // Backup contracts
    let contractsBackup = await queueOperation(async () => {
      const result = await db.getAllAsync('SELECT * FROM contracts;');
      logDbOperation('reset', 'contracts-backed-up', { count: result.length });
      return result;
    }, 'Backup contracts').catch(error => {
      logDbOperation('reset', 'backup-failed', { error });
      return [];
    });

    // Clear old data
    await queueOperation(async () => {
      const tables = [
        { name: DB_CONFIG.tables.background_tracks, condition: 'date(timestamp) < date(?)' },
        { name: DB_CONFIG.tables.contract_checkins, condition: 'date(timestamp) < date(?)' },
        { name: DB_CONFIG.tables.app_state, condition: 'key != "db_version"' }
      ];
      
      for (const table of tables) {
        logDbOperation('reset', `clearing-${table.name}`);
        const sql = table.condition ? 
          `DELETE FROM ${table.name} WHERE ${table.condition};` :
          `DELETE FROM ${table.name};`;
        
        await db.execAsync(sql, table.condition ? [today] : []);
      }
    }, 'Clear old data');

    // Reinitialize structure
    await migrateDatabase(db, 0, DB_CONFIG.version);

    // Restore contracts if available
    if (contractsBackup?.length > 0) {
      logDbOperation('reset', 'restoring-contracts', { count: contractsBackup.length });
      let restoredCount = 0;
      
      for (const contract of contractsBackup) {
        try {
          const contractData = JSON.parse(contract.contract_data);
          const filteredData = contractData.map(item => {
            if (item.CheckIn && !isSameDay(new Date(item.CheckIn), new Date())) {
              return { ...item, isCheckedIn: false, CheckIn: null };
            }
            return item;
          });

          await queueOperation(async () => {
            await db.runAsync(
              'INSERT OR REPLACE INTO contracts (id, contract_data, employee_name) VALUES (?, ?, ?)',
              [contract.id, JSON.stringify(filteredData), contract.employee_name]
            );
            restoredCount++;
          }, `Restore contract ${contract.id}`);
        } catch (error) {
          logDbOperation('reset', 'contract-restore-failed', { 
            contractId: contract.id, 
            error 
          });
        }
      }
      
      logDbOperation('reset', 'contracts-restored', {
        restored: restoredCount,
        total: contractsBackup.length
      });
    }

    // Get final stats
    const [tracksCount, checkinsCount] = await Promise.all([
      queueOperation(async () => {
        return await db.getFirstAsync('SELECT COUNT(*) as count FROM background_tracks;');
      }, 'Count remaining tracks'),
      queueOperation(async () => {
        return await db.getFirstAsync('SELECT COUNT(*) as count FROM contract_checkins;');
      }, 'Count remaining check-ins')
    ]);

    logDbOperation('reset', 'completed', {
      stats: {
        remainingTracks: tracksCount?.count || 0,
        remainingCheckins: checkinsCount?.count || 0,
        restoredContracts: contractsBackup?.length || 0
      }
    });
    
    return true;
  } catch (error) {
    logDbOperation('reset', 'failed', { error });
    throw error;
  }
};

// Export all needed functions
export {
  getDb,
  executeWithLog,
  forceCleanupDatabase
};